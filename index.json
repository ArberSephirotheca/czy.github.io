[{"categories":["Database"],"content":"这篇文章讨论了redis的基础数据结构和特点 ","date":"2021-04-22","objectID":"/redis/:0:0","tags":["Database","NoSQL"],"title":"Redis","uri":"/redis/"},{"categories":["Database"],"content":"数据类型 String List Linked Lists. Set collection of unique, unsorted elemnts. Hash * Zest ","date":"2021-04-22","objectID":"/redis/:1:0","tags":["Database","NoSQL"],"title":"Redis","uri":"/redis/"},{"categories":["Database"],"content":"数据结构 字典 存放key-value的数据结构. 使用哈希表作为底层. 用拉链法(每个bucket有一个链表)来解决哈希冲突. 包含2个哈希表，是为了在扩容时，把rehash过后的key-value放到另外一个字典上，完成交换. rehash的过程是渐进式的，每次CRUD的时候，都会顺带做一点rehash的工作. 跳跃表 Skip ListAlt text \" Skip List Zest 的底层实现. 基于多指针有序列表. 在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找. 插入速度快，相比起红黑树等不需要旋转，支持无锁操作. 插入，删除，搜索都是 O(logn). ","date":"2021-04-22","objectID":"/redis/:2:0","tags":["Database","NoSQL"],"title":"Redis","uri":"/redis/"},{"categories":["Database"],"content":"特点 速度快，因为数据存在内存中，并且底层kv使用hashmap来实现，查找和操作都是O(1). 单线程， 不用担心 Race Condition. ","date":"2021-04-22","objectID":"/redis/:3:0","tags":["Database","NoSQL"],"title":"Redis","uri":"/redis/"},{"categories":["Database"],"content":"集群 主从复制 master-slave replicationAlt text \" master-slave replication redis 提供了 复制replication功能，可以实现当master数据库更新后，自动将更新的数据同步到其他slaves数据库中. master数据库可以进行读写操作. slave数据库只能进行读操作. 优点: 容灾恢复. 读写分离，分担master读写的压力. 在同步期间，master和slave服务器是非阻塞(non-blocking)，客户端可以操作. 缺点: Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败. Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂. 哨兵Sentinel模式 sentinel replicationAlt text \" sentinel replication 哨兵是独立进程，通过向redis服务器发送request并等待response来监控运行多个redis实例. 当哨兵检测到master服务器宕机，就会将其中一个slave服务器切换成master并通知其他服务器. 优点: 主从可以自动切换，系统更健壮，可用性更高. 缺点: Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂. 集群Cluster模式 clusterAlt text \" cluster 在每台redis节点上储存不同的数据. 服务器之间互相连接，一个服务器可以访问任意一个服务器. 采用hash slot来分配节点地址. redis cluster 有16384个hash slot, 通过对每个key进行 mod 16384来决定节点的位置. 每个节点负责一部分的hash slot. ","date":"2021-04-22","objectID":"/redis/:4:0","tags":["Database","NoSQL"],"title":"Redis","uri":"/redis/"},{"categories":["Database"],"content":"同步 slave服务器向master服务器发送sync命令. 收到sync命令后，master服务器执行bgsave命令，用来生成rdb文件，并在一个缓冲区中记录现在开始执行的写命. bgsave执行完后，发送给slave服务器使其更新数据. master服务器再将缓冲区记录的写命令发送给从服务器，slave服务器执行完这些写命令后，此时的数据库状态便和master服务器一致了. ","date":"2021-04-22","objectID":"/redis/:5:0","tags":["Database","NoSQL"],"title":"Redis","uri":"/redis/"},{"categories":["Database"],"content":"持久化 redis因为是内存型rdb，为了保证数据不丢失，会在一定频率下把内存数据保存到硬盘当中. 可用在AOF文件写指令来设置保存数据的频率(etc. always, everysec, no). ","date":"2021-04-22","objectID":"/redis/:6:0","tags":["Database","NoSQL"],"title":"Redis","uri":"/redis/"},{"categories":["Algorithm"],"content":"理解归并排序","date":"2020-03-27","objectID":"/mergesort/","tags":["Sort"],"title":"Algorithm - MergeSort","uri":"/mergesort/"},{"categories":["Algorithm"],"content":"这篇文章讨论了归并排序的原理 ","date":"2020-03-27","objectID":"/mergesort/:0:0","tags":["Sort"],"title":"Algorithm - MergeSort","uri":"/mergesort/"},{"categories":["Algorithm"],"content":"原理 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列. 设定两个指针，最初位置分别为两个已经排序序列的起始位置. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置. 重复步骤 3 直到某一指针达到序列尾. 将另一序列剩下的所有元素直接复制到合并序列尾. ","date":"2020-03-27","objectID":"/mergesort/:1:0","tags":["Sort"],"title":"Algorithm - MergeSort","uri":"/mergesort/"},{"categories":["Algorithm"],"content":"实现 func mergeSort(arr []int) []int{ length := len(arr) if length \u003c 2{ return arr } mid := length/2 left := arr[0:mid] right := arr[mid:] return merge(mergeSort(left), mergeSort(right)) } func merge(left []int, right []int) []int{ var result []int for len(left) != 0 \u0026\u0026 len(right) != 0{ if left[0] \u003c right[0]{ result = append(result, left[0]) left = left[1:] }else{ result = append(result, right[0]) right = right[1:] } for len(left) != 0{ result = append(result, left[0]) left = left[1:] } for len(right) != 0{ result = append(result, right[0]) right = right[1:] } } return result } ","date":"2020-03-27","objectID":"/mergesort/:2:0","tags":["Sort"],"title":"Algorithm - MergeSort","uri":"/mergesort/"},{"categories":["Algorithm"],"content":"时间复杂度 Average Case: O(nlogn) Worst Case: O(nlogn) ","date":"2020-03-27","objectID":"/mergesort/:3:0","tags":["Sort"],"title":"Algorithm - MergeSort","uri":"/mergesort/"},{"categories":["Algorithm"],"content":"优点 时间复杂度稳定 ","date":"2020-03-27","objectID":"/mergesort/:4:0","tags":["Sort"],"title":"Algorithm - MergeSort","uri":"/mergesort/"},{"categories":["Algorithm"],"content":"缺点 虽然 Average Case 都是O(nlogn)，但QuickSort比归并排序稍快 ","date":"2020-03-27","objectID":"/mergesort/:5:0","tags":["Sort"],"title":"Algorithm - MergeSort","uri":"/mergesort/"},{"categories":["OS"],"content":"探讨内存对齐","date":"2020-03-04","objectID":"/memory_alignment/","tags":["OS","Memory"],"title":"OS - Memory Alignment","uri":"/memory_alignment/"},{"categories":["OS"],"content":"这篇文章讨论了内存对齐的原理 ","date":"2020-03-04","objectID":"/memory_alignment/:0:0","tags":["OS","Memory"],"title":"OS - Memory Alignment","uri":"/memory_alignment/"},{"categories":["OS"],"content":"内存条的结构 每个内存条一面是一个 Rank 每面Rank一般包含8个 Chips. 每个Chips包含8个 Banks. 计算机通过选择Banks的 row 和 col 来定位地址. ","date":"2020-03-04","objectID":"/memory_alignment/:1:0","tags":["OS","Memory"],"title":"OS - Memory Alignment","uri":"/memory_alignment/"},{"categories":["OS"],"content":"结构的优点 通过对8个 Chips 进行并行parallelism操作，提高了内存访问效率. ","date":"2020-03-04","objectID":"/memory_alignment/:2:0","tags":["OS","Memory"],"title":"OS - Memory Alignment","uri":"/memory_alignment/"},{"categories":["OS"],"content":"结构的缺陷 虽然 8 byte8 字节 物理上不是连续存在，但共用8个Chips的同一个地址. 这也导致了address只能是8的倍数%8=0. ","date":"2020-03-04","objectID":"/memory_alignment/:3:0","tags":["OS","Memory"],"title":"OS - Memory Alignment","uri":"/memory_alignment/"},{"categories":["OS"],"content":"解决方案 CPU分两次读 如果当用户想要从不属于Chips(这里是8)倍数的地址开始读取数据，CPU会读取前后8个bytes的地址16字节来获得数据. 但这也导致了性能的降低. ","date":"2020-03-04","objectID":"/memory_alignment/:4:0","tags":["OS","Memory"],"title":"OS - Memory Alignment","uri":"/memory_alignment/"},{"categories":["OS"],"content":"更优秀的解决方案 内存对齐 为了保持高效的运行，编译器会把不同类型/不同大小的数据安排到合适的地点并占用合适的长度. 内存对齐要求数据储存的地址是对其边界的倍数 int32 的对齐边界是 4 bytes4 字节，所以它所在的地址一定是 4 的倍数%4=0. int16 的对齐边界是 2 bytes2 字节，所以它所在的地址一定是 2 的倍数%2=0. 举例: type a struct{ A int8 B int16 C int32 D int64 } type b struct{ B int16 A int8 C int64 D int32 } 虽然上面2个struct内容相同，但data type的排序却会导致后者b struct占用较多的字节. 第一种排序占用 16 bytes16 字节. 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0xa0 0xa1 0xa2 0xa3 0xa4 0xa5 8 16 16 32 32 32 32 64 64 64 64 64 64 64 64 第二种排序占用 24 bytes24 字节. 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0xa0 0xa1 0xa2 0xa3 0xa4 0xa5 0xa6 0xa7 0xa8 0xa9 0xb0 0xb1 0xb2 0xb3 16 16 8 64 64 64 64 64 64 64 32 32 32 32 Golang 语言下可以用 unsafe.sizeof 来查看 struct 的大小. Reference: https://www.bilibili.com/video/BV1hv411x7we?p=3 ","date":"2020-03-04","objectID":"/memory_alignment/:5:0","tags":["OS","Memory"],"title":"OS - Memory Alignment","uri":"/memory_alignment/"},{"categories":["Algorithm"],"content":"探讨快排的原理","date":"2020-02-22","objectID":"/quicksort/","tags":["Sort"],"title":"Algorithm - QuickSort","uri":"/quicksort/"},{"categories":["Algorithm"],"content":"这篇文章讨论了快排的原理 ","date":"2020-02-22","objectID":"/quicksort/:0:0","tags":["Sort"],"title":"Algorithm - QuickSort","uri":"/quicksort/"},{"categories":["Algorithm"],"content":"原理 有一个大小为[0…n]的数组，我们要将它进行排序. 选中数字中的一个元素当成pivot. 把所有小于pivot的元素放在左边. 把所有大于pivot的元素放在右边. 对于pviot左侧的数组执行第二步的步骤. 对于pviot右侧的数组进行第二步的步骤. 重复以上步骤. ","date":"2020-02-22","objectID":"/quicksort/:1:0","tags":["Sort"],"title":"Algorithm - QuickSort","uri":"/quicksort/"},{"categories":["Algorithm"],"content":"实现 int partitions(vector\u003cint\u003e\u0026arr, int l, int r){ int pivot = l + (r-l)/2; int i = l; int j = r; while(true){ //find leftmost element greater than or equal to pivot while(arr[i] \u003c pivot) i++; //find rightmost element less than or equal to pivot while(arr[j] \u003e pivot) j--; //two pointers met if(i \u003e= j) return j; swap(arr[i], arr[j]); } arr[l] = pivot; return l; } void quicksort(vector\u003cint\u003e\u0026arr, int l, int r){ if(l \u003c r){ int pivot = partitions(arr, l, h); quicksort(arr, l, pivot); quicksort(arr, pivot+1, r); } } ","date":"2020-02-22","objectID":"/quicksort/:2:0","tags":["Sort"],"title":"Algorithm - QuickSort","uri":"/quicksort/"},{"categories":["Algorithm"],"content":"时间复杂度 Average Case: O(nlogn) Worst Case: O(n2) ","date":"2020-02-22","objectID":"/quicksort/:3:0","tags":["Sort"],"title":"Algorithm - QuickSort","uri":"/quicksort/"},{"categories":["Algorithm"],"content":"基准的选择 固定位置 通常选择首个/最后元素作为基准. 三数取中(medium of three) 取待排序数组中间，首部和尾部中第二大的元素作为基准 实现: void getmid(vecotr\u003cint\u003e arr, int l, int r){ int mid = l + (r-l)/2; int index = 0; if(arr[l] \u003c= arr[mid] \u0026\u0026 arr[l] \u003e= arr[r]) index = l; else if(arr[r] \u003c= arr[mid] \u0026\u0026 arr[r] \u003e= arr[l]) index = r; else index = mid; //put medium value at the front swap(arr[l],arr[mid]); } ","date":"2020-02-22","objectID":"/quicksort/:4:0","tags":["Sort"],"title":"Algorithm - QuickSort","uri":"/quicksort/"},{"categories":["Algorithm"],"content":"缺点 如果初始序列基本为有序，则时间复杂度属于Worst Case. Pivot的选取极大影响了快排的效率. ","date":"2020-02-22","objectID":"/quicksort/:5:0","tags":["Sort"],"title":"Algorithm - QuickSort","uri":"/quicksort/"}]